{"version":3,"file":"enigma.min.js","sources":["node_modules/node-event-emitter/index.js","src/event-emitter.js","src/session.js","src/cache.js","src/schema.js","src/rpc-resolver.js","src/rpc.js","src/suspend-resume.js","src/interceptors/request/delta.js","src/interceptors/response/api.js","node_modules/extend/index.js","src/json-patch.js","src/interceptors/response/delta.js","src/interceptors/response/out-param.js","src/intercept.js","src/interceptors/response/error.js","src/interceptors/response/result.js","src/api-cache.js","src/qix.js"],"sourcesContent":["/**\n * Utility functions\n */\n\nvar util = {};\n\nutil.isObject = function isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nutil.isNumber = function isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nutil.isUndefined = function isUndefined(arg) {\n  return arg === void 0;\n}\n\nutil.isFunction = function isFunction(arg){\n  return typeof arg === 'function';\n}\n\n\n/**\n * EventEmitter class\n */\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\nEventEmitter.init = function() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!util.isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error' && !this._events.error) {\n    er = arguments[1];\n    if (er instanceof Error) {\n      throw er; // Unhandled 'error' event\n    } else {\n      throw Error('Uncaught, unspecified \"error\" event.');\n    }\n    return false;\n  }\n\n  handler = this._events[type];\n\n  if (util.isUndefined(handler))\n    return false;\n\n  if (util.isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        len = arguments.length;\n        args = new Array(len - 1);\n        for (i = 1; i < len; i++)\n          args[i - 1] = arguments[i];\n        handler.apply(this, args);\n    }\n  } else if (util.isObject(handler)) {\n    len = arguments.length;\n    args = new Array(len - 1);\n    for (i = 1; i < len; i++)\n      args[i - 1] = arguments[i];\n\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!util.isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              util.isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (util.isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (util.isObject(this._events[type]) && !this._events[type].warned) {\n    var m;\n    if (!util.isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n\n      if (util.isFunction(console.error)) {\n        console.error('(node) warning: possible EventEmitter memory ' +\n                      'leak detected. %d listeners added. ' +\n                      'Use emitter.setMaxListeners() to increase limit.',\n                      this._events[type].length);\n      }\n      if (util.isFunction(console.trace))\n        console.trace();\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!util.isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!util.isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (util.isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (util.isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (util.isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (Array.isArray(listeners)) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (util.isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (util.isFunction(emitter._events[type]))\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n","import EventEmitter from 'node-event-emitter';\n\n/**\n* @module EventEmitter\n*/\nexport default {\n\n  /**\n  * Function used to add event handling to objects passed in.\n  * @param {Object} obj Object instance that will get event handling.\n  */\n  mixin: (obj) => {\n    Object.keys(EventEmitter.prototype).forEach((key) => {\n      obj[key] = EventEmitter.prototype[key];\n    });\n    EventEmitter.init(obj);\n  },\n};\n","import EventEmitter from './event-emitter';\n\nconst RPC_CLOSE_NORMAL = 1000;\nconst RPC_CLOSE_MANUAL_SUSPEND = 4000;\n\nlet cacheId = 0;\n\nclass Session {\n  /**\n  * Creates a new Session instance.\n  * @param {Object} options The configuration option for this class.\n  * @param {ApiCache} options.apis The ApiCache instance to bridge events towards.\n  * @param {Object} options.config The configuration object for this session.\n  * @param {Intercept} options.intercept The intercept instance to use.\n  * @param {RPC} options.rpc The RPC instance to use when communicating towards Engine.\n  * @param {SuspendResume} options.suspendResume The SuspendResume instance to use.\n  */\n  constructor(options) {\n    const session = this;\n    Object.assign(session, options);\n    this.Promise = this.config.Promise;\n    this.definition = this.config.definition;\n    EventEmitter.mixin(session);\n    cacheId += 1;\n    session.id = cacheId;\n    session.rpc.on('socket-error', session.onRpcError.bind(session));\n    session.rpc.on('closed', session.onRpcClosed.bind(session));\n    session.rpc.on('message', session.onRpcMessage.bind(session));\n    session.rpc.on('notification', session.onRpcNotification.bind(session));\n    session.rpc.on('traffic', session.onRpcTraffic.bind(session));\n    session.on('closed', () => session.onSessionClosed());\n  }\n\n  /**\n  * Event handler for re-triggering error events from RPC.\n  * @emits socket-error\n  * @param {Error} err Webocket error event.\n  */\n  onRpcError(err) {\n    if (this.suspendResume.isSuspended) {\n      return;\n    }\n    this.emit('socket-error', err);\n  }\n\n  /**\n  * Event handler for the RPC close event.\n  * @emits suspended\n  * @emits closed\n  * @param {Event} evt WebSocket close event.\n  */\n  onRpcClosed(evt) {\n    if (this.suspendResume.isSuspended) {\n      return;\n    }\n    if (evt.code === RPC_CLOSE_NORMAL || evt.code === RPC_CLOSE_MANUAL_SUSPEND) {\n      return;\n    }\n    if (this.config.suspendOnClose) {\n      this.suspendResume.suspend().then(() => this.emit('suspended', { initiator: 'network' }));\n    } else {\n      this.emit('closed', evt);\n    }\n  }\n\n  /**\n  * Event handler for the RPC message event.\n  * @param {Object} response JSONRPC response.\n  */\n  onRpcMessage(response) {\n    if (this.suspendResume.isSuspended) {\n      return;\n    }\n    if (response.change) {\n      response.change.forEach(handle => this.emitHandleChanged(handle));\n    }\n    if (response.close) {\n      response.close.forEach(handle => this.emitHandleClosed(handle));\n    }\n  }\n\n  /**\n  * Event handler for the RPC notification event.\n  * @emits notification:*\n  * @emits notification:[JSONRPC notification name]\n  * @param {Object} response The JSONRPC notification.\n  */\n  onRpcNotification(response) {\n    this.emit('notification:*', response.method, response.params);\n    this.emit(`notification:${response.method}`, response.params);\n  }\n\n  /**\n  * Event handler for the RPC traffic event.\n  * @emits traffic:*\n  * @emits traffic:sent\n  * @emits traffic:received\n  * @param {String} dir The traffic direction, sent or received.\n  * @param {Object} data JSONRPC request/response/WebSocket message.\n  */\n  onRpcTraffic(dir, data) {\n    this.emit('traffic:*', dir, data);\n    this.emit(`traffic:${dir}`, data);\n  }\n\n  /**\n  * Event handler for cleaning up API instances when a session has been closed.\n  * @emits api#closed\n  */\n  onSessionClosed() {\n    this.apis.getApis().forEach((entry) => {\n      entry.api.emit('closed');\n      entry.api.removeAllListeners();\n    });\n    this.apis.clear();\n  }\n\n  /**\n   * Function used to get an API for a backend object.\n   * @param {Object} args Arguments used to create object API.\n   * @param {Number} args.handle Handle of the backend object.\n   * @param {String} args.id ID of the backend object.\n   * @param {String} args.type QIX type of the backend object. Can for example\n   *                           be \"Doc\" or \"GenericVariable\".\n   * @param {String} args.genericType Custom type of the backend object, if defined in qInfo.\n   * @returns {*} Returns the generated and possibly augmented API.\n   */\n  getObjectApi(args) {\n    const {\n      handle, id, type, genericType,\n    } = args;\n    let api = this.apis.getApi(handle);\n    if (api) {\n      return api;\n    }\n    const factory = this.definition.generate(type);\n    api = factory(this, handle, id, genericType);\n    this.apis.add(handle, api);\n    return api;\n  }\n\n  /**\n  * Establishes the RPC socket connection and returns the Global instance.\n  * @returns {Promise} Eventually resolved if the connection was successful.\n  */\n  open() {\n    if (!this.globalPromise) {\n      const args = {\n        handle: -1,\n        id: 'Global',\n        type: 'Global',\n        genericType: 'Global',\n      };\n      this.globalPromise = this.rpc.open()\n        .then(() => this.getObjectApi(args))\n        .then((global) => {\n          this.emit('opened');\n          return global;\n        });\n    }\n    return this.globalPromise;\n  }\n\n  /**\n  * Function used to send data on the RPC socket.\n  * @param {Object} request The request to be sent. (data and some meta info)\n  * @returns {Object} Returns a promise instance.\n  */\n  send(request) {\n    if (this.suspendResume.isSuspended) {\n      return this.Promise.reject(new Error('Session suspended'));\n    }\n    request.id = this.rpc.createRequestId();\n    const promise = this.intercept.executeRequests(this, this.Promise.resolve(request))\n      .then((augmentedRequest) => {\n        const data = Object.assign({}, this.config.protocol, augmentedRequest);\n        // the outKey value is used by multiple-out interceptor, at some point\n        // we need to refactor that implementation and figure out how to transport\n        // this value without hijacking the JSONRPC request object:\n        delete data.outKey;\n        const response = this.rpc.send(data);\n        augmentedRequest.retry = () => this.send(request);\n        return this.intercept.executeResponses(this, response, augmentedRequest);\n      });\n    Session.addToPromiseChain(promise, 'requestId', request.id);\n    return promise;\n  }\n\n  /**\n  * Suspends the session (\"sleeping state\"), and closes the RPC connection.\n  * @emits suspended\n  * @returns {Promise} Eventually resolved when the RPC connection is closed.\n  */\n  suspend() {\n    return this.suspendResume.suspend()\n      .then(() => this.emit('suspended', { initiator: 'manual' }));\n  }\n\n  /**\n  * Resumes a previously suspended session.\n  * @param {Boolean} onlyIfAttached If true, resume only if the session was re-attached.\n  * @returns {Promise} Eventually resolved if the session was successfully resumed,\n  *                    otherwise rejected.\n  */\n  resume(onlyIfAttached) {\n    return this.suspendResume.resume(onlyIfAttached).then((value) => {\n      this.emit('resumed');\n      return value;\n    });\n  }\n\n  /**\n  * Function used to close the session.\n  * @returns {Promise} Eventually resolved when the RPC connection is closed.\n  */\n  close() {\n    this.globalPromise = undefined;\n    return this.rpc.close().then(evt => this.emit('closed', evt));\n  }\n\n  /**\n  * Given a handle, this function will emit the 'changed' event on the\n  * corresponding API instance.\n  * @param {Number} handle The handle of the API instance.\n  * @emits api#changed\n  */\n  emitHandleChanged(handle) {\n    const api = this.apis.getApi(handle);\n    if (api) {\n      api.emit('changed');\n    }\n  }\n\n  /**\n  * Given a handle, this function will emit the 'closed' event on the\n  * corresponding API instance.\n  * @param {Number} handle The handle of the API instance.\n  * @emits api#closed\n  */\n  emitHandleClosed(handle) {\n    const api = this.apis.getApi(handle);\n    if (api) {\n      api.emit('closed');\n      api.removeAllListeners();\n    }\n  }\n\n  /**\n  * Function used to add info on the promise chain.\n  * @private\n  * @param {Promise} promise The promise to add info on.\n  * @param {String} name The property to add info on.\n  * @param {Any} value The info to add.\n  */\n  static addToPromiseChain(promise, name, value) {\n    promise[name] = value;\n    const { then } = promise;\n    promise.then = function patchedThen(...params) {\n      const chain = then.apply(this, params);\n      Session.addToPromiseChain(chain, name, value);\n      return chain;\n    };\n  }\n}\n\nexport default Session;\n","/**\n* Key-value cache\n*/\nclass KeyValueCache {\n  constructor() {\n    this.entries = {};\n  }\n\n  /**\n  * Adds an entry.\n  * @function KeyValueCache#add\n  * @param {String} key The key representing an entry.\n  * @param {*} entry The entry to be added.\n  */\n  add(key, entry) {\n    key += '';\n    if (typeof this.entries[key] !== 'undefined') {\n      throw new Error(`Entry already defined with key ${key}`);\n    }\n    this.entries[key] = entry;\n  }\n\n  /**\n  * Sets an entry.\n  * @function KeyValueCache#set\n  * @param {String} key The key representing an entry.\n  * @param {*} entry The entry.\n  */\n  set(key, entry) {\n    key += '';\n    this.entries[key] = entry;\n  }\n\n  /**\n  * Removes an entry.\n  * @function KeyValueCache#remove\n  * @param {String} key The key representing an entry.\n  */\n  remove(key) {\n    delete this.entries[key];\n  }\n\n  /**\n  * Gets an entry.\n  * @function KeyValueCache#get\n  * @param {String} key The key representing an entry.\n  * @returns {*} The entry for the key.\n  */\n  get(key) {\n    return this.entries[key];\n  }\n\n  /**\n  * Gets a list of all entries.\n  * @function KeyValueCache#getAll\n  * @returns {Array} The list of entries including its `key` and `value` properties.\n  */\n  getAll() {\n    return Object.keys(this.entries).map(key => ({\n      key,\n      value: this.entries[key],\n    }));\n  }\n\n  /**\n  * Gets a key for an entry.\n  * @function KeyValueCache#getKey\n  * @param {*} entry The entry to locate the key for.\n  * @returns {String} The key representing an entry.\n  */\n  getKey(entry) {\n    return Object.keys(this.entries).filter(key => this.entries[key] === entry)[0];\n  }\n\n  /**\n  * Clears the cache of all entries.\n  * @function KeyValueCache#clear\n  */\n  clear() {\n    this.entries = {};\n  }\n}\n\nexport default KeyValueCache;\n","import KeyValueCache from './cache';\nimport Events from './event-emitter';\n\nconst { hasOwnProperty } = Object.prototype;\n\n/**\n* Returns the camelCase counterpart of a symbol.\n* @param {String} symbol The symbol.\n* @return the camelCase counterpart.\n*/\nfunction toCamelCase(symbol) {\n  return symbol.substring(0, 1).toLowerCase() + symbol.substring(1);\n}\n\n/**\n * A facade function that allows parameters to be passed either by name\n * (through an object), or by position (through an array).\n * @param {Function} base The function that is being overriden. Will be\n *                        called with parameters in array-form.\n * @param {Object} defaults Parameter list and it's default values.\n * @param {*} params The parameters.\n */\nfunction namedParamFacade(base, defaults, ...params) {\n  if (params.length === 1 && typeof params[0] === 'object' && !Array.isArray(params[0])) {\n    const valid = Object.keys(params[0]).every(key => hasOwnProperty.call(defaults, key));\n    if (valid) {\n      params = Object.keys(defaults).map(key => params[0][key] || defaults[key]);\n    }\n  }\n  return base.apply(this, params);\n}\n\n/**\n* Qix schema definition.\n*/\nclass Schema {\n  /**\n  * Create a new schema instance.\n  * @param {Configuration} config The configuration for QIX.\n  */\n  constructor(config) {\n    this.config = config;\n    this.Promise = config.Promise;\n    this.schema = config.schema;\n    this.mixins = new KeyValueCache();\n    this.types = new KeyValueCache();\n  }\n\n  /**\n  * Function used to add a mixin object to the mixin cache. Will be mixed into the API\n  * of the specified key when generated.\n  * @param {Object} mixin Mixin object.\n  * @param {String|Array<String>} mixin.types String or array of strings containing the\n  *                                           API-types that will be mixed in.\n  * @param {Object} [mixin.extend] Object literal containing the methods that\n  *                                will be extended on the specified API.\n  * @param {Object} [mixin.override] Object literal containing the methods to\n  *                                  override existing methods.\n  * @param {Function} [mixin.init] Init function that, if defined, will run when an API is\n  *                                instantiated. It runs with Promise and API object as parameters.\n  */\n  registerMixin({\n    types, type, extend, override, init,\n  }) {\n    if (!Array.isArray(types)) {\n      types = [types];\n    }\n    // to support a single type\n    if (type) {\n      types.push(type);\n    }\n    const cached = { extend, override, init };\n    types.forEach((typeKey) => {\n      const entryList = this.mixins.get(typeKey);\n      if (entryList) {\n        entryList.push(cached);\n      } else {\n        this.mixins.add(typeKey, [cached]);\n      }\n    });\n  }\n\n  /**\n  * Function used to generate a type definition.\n  * @param {String} type The type.\n  * @returns {{create: Function, def: Object}} Returns an object with a definition\n  *          of the type and a create factory.\n  */\n  generate(type) {\n    const entry = this.types.get(type);\n    if (entry) {\n      return entry;\n    }\n    if (!this.schema.structs[type]) {\n      throw new Error(`${type} not found`);\n    }\n    const factory = this.generateApi(type, this.schema.structs[type]);\n    this.types.add(type, factory);\n    return factory;\n  }\n\n  /**\n  * Function used to generate an API definition for a given type.\n  * @param {String} type The type to generate.\n  * @param {Object} schema The schema describing the type.\n  * @returns {{create: (function(session:Object, handle:Number, id:String,\n  *          customKey:String)), def: Object}} Returns the API definition.\n  */\n  generateApi(type, schema) {\n    const api = Object.create({});\n\n    this.generateDefaultApi(api, schema); // Generate default\n    this.mixinType(type, api); // Mixin default type\n    this.mixinNamedParamFacade(api, schema); // Mixin named parameter support\n\n    return function create(session, handle, id, customKey) {\n      const instance = Object.create(api);\n\n      Events.mixin(instance); // Always mixin event-emitter per instance\n\n      Object.defineProperties(instance, {\n        session: {\n          enumerable: true,\n          value: session,\n        },\n        handle: {\n          enumerable: true,\n          value: handle,\n          writable: true,\n        },\n        id: {\n          enumerable: true,\n          value: id,\n        },\n        type: {\n          enumerable: true,\n          value: type,\n        },\n        genericType: {\n          enumerable: true,\n          value: customKey,\n        },\n      });\n\n      let mixinList = this.mixins.get(type) || [];\n      if (customKey !== type) {\n        this.mixinType(customKey, instance); // Mixin custom types\n        mixinList = mixinList.concat(this.mixins.get(customKey) || []);\n      }\n      mixinList.forEach((mixin) => {\n        if (typeof mixin.init === 'function') {\n          mixin.init({ config: this.config, api: instance });\n        }\n      });\n\n      return instance;\n    }.bind(this);\n  }\n\n  /**\n  * Function used to generate the methods with the right handlers to the object\n  * API that is being generated.\n  * @param {Object} api The object API that is currently being generated.\n  * @param {Object} schema The API definition.\n  */\n  generateDefaultApi(api, schema) {\n    Object.keys(schema).forEach((method) => {\n      const out = schema[method].Out;\n      const outKey = out.length === 1 ? out[0].Name : -1;\n      const fnName = toCamelCase(method);\n\n      api[fnName] = function generatedMethod(...params) {\n        return this.session.send({\n          handle: this.handle,\n          method,\n          params,\n          outKey,\n        });\n      };\n    });\n  }\n\n  /**\n  * Function used to add mixin methods to a specified API.\n  * @param {String} type Used to specify which mixin should be woven in.\n  * @param {Object} api The object that will be woven.\n  */\n  mixinType(type, api) {\n    const mixinList = this.mixins.get(type);\n    if (mixinList) {\n      mixinList.forEach(({ extend = {}, override = {} }) => {\n        Object.keys(override).forEach((key) => {\n          if (typeof api[key] === 'function' && typeof override[key] === 'function') {\n            const baseFn = api[key];\n            api[key] = function wrappedFn(...args) {\n              return override[key].apply(this, [baseFn.bind(this), ...args]);\n            };\n          } else {\n            throw new Error(`No function to override. Type: ${type} function: ${key}`);\n          }\n        });\n        Object.keys(extend).forEach((key) => {\n          // handle overrides\n          if (typeof api[key] === 'function' && typeof extend[key] === 'function') {\n            throw new Error(`Extend is not allowed for this mixin. Type: ${type} function: ${key}`);\n          } else {\n            api[key] = extend[key];\n          }\n        });\n      });\n    }\n  }\n\n  /**\n  * Function used to mixin the named parameter facade.\n  * @param {Object} api The object API that is currently being generated.\n  * @param {Object} schema The API definition.\n  */\n  mixinNamedParamFacade(api, schema) {\n    Object.keys(schema).forEach((key) => {\n      const fnName = toCamelCase(key);\n      const base = api[fnName];\n      const defaults = schema[key].In.reduce((result, item) => {\n        result[item.Name] = item.DefaultValue;\n        return result;\n      }, {});\n\n      api[fnName] = function namedParamWrapper(...params) {\n        return namedParamFacade.apply(this, [base, defaults, ...params]);\n      };\n    });\n  }\n}\n\nexport default Schema;\n","import Events from './event-emitter';\n\n/**\n * Helper class for handling RPC calls\n */\nclass RPCResolver {\n  constructor(id, resolve, reject) {\n    Events.mixin(this);\n    this.id = id;\n    this.resolve = resolve;\n    this.reject = reject;\n  }\n\n  resolveWith(data) {\n    this.resolve(data);\n    this.emit('resolved', this.id);\n  }\n\n  rejectWith(err) {\n    this.reject(err);\n    this.emit('rejected', this.id);\n  }\n}\n\nexport default RPCResolver;\n","import Events from './event-emitter';\nimport RPCResolver from './rpc-resolver';\n\n/**\n* This class handles remote procedure calls on a web socket.\n*/\nclass RPC {\n  /**\n  * Create a new RPC instance.\n  * @param {Object} options The configuration options for this class.\n  * @param {Function} options.Promise The promise constructor to use.\n  * @param {String} options.url The complete websocket URL used to connect.\n  * @param {Function} options.createSocket The function callback to create a WebSocket.\n  */\n  constructor(options) {\n    Object.assign(this, options);\n    Events.mixin(this);\n    this.resolvers = {};\n    this.requestId = 0;\n    this.openedPromise = undefined;\n  }\n\n  /**\n  * Opens a connection to the configured endpoint.\n  * @param {Boolean} force - ignores all previous and outstanding open calls if set to true.\n  * @returns {Object} A promise instance.\n  */\n  open(force = false) {\n    if (!force && this.openedPromise) {\n      return this.openedPromise;\n    }\n\n    try {\n      this.socket = this.createSocket(this.url);\n    } catch (err) {\n      return this.Promise.reject(err);\n    }\n\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n    this.socket.onerror = this.onError.bind(this);\n    this.socket.onmessage = this.onMessage.bind(this);\n    this.openedPromise = new this.Promise((resolve, reject) => this.registerResolver('opened', resolve, reject));\n    this.closedPromise = new this.Promise((resolve, reject) => this.registerResolver('closed', resolve, reject));\n    return this.openedPromise;\n  }\n\n  /**\n  * Resolves the open promise when a connection is successfully established.\n  */\n  onOpen() {\n    this.resolvers.opened.resolveWith(() => this.closedPromise);\n  }\n\n  /**\n  * Resolves the close promise when a connection is closed.\n  * @param {Object} event - The event describing close.\n  */\n  onClose(event) {\n    this.emit('closed', event);\n    this.resolvers.closed.resolveWith(event);\n    this.rejectAllOutstandingResolvers({ code: -1, message: 'Socket closed' });\n  }\n\n  /**\n  * Closes a connection.\n  * @param {Number} [code=1000] - The reason code for closing the connection.\n  * @param {String} [reason=\"\"] - The human readable string describing why the connection is closed.\n  * @returns {Object} Returns a promise instance.\n  */\n  close(code = 1000, reason = '') {\n    if (this.socket) {\n      this.socket.close(code, reason);\n      this.socket = null;\n    }\n    return this.closedPromise;\n  }\n\n  /**\n  * Emits an error event and rejects the open promise if an error is raised on the connection.\n  * @param {Object} event - The event describing the error.\n  */\n  onError(event) {\n    if (this.resolvers.opened) {\n      this.resolvers.opened.rejectWith(event);\n    } else {\n      // only emit errors after the initial open promise has been resolved,\n      // this makes it possible to catch early websocket errors as well\n      // as run-time ones:\n      this.emit('socket-error', event);\n    }\n    this.rejectAllOutstandingResolvers({ code: -1, message: 'Socket error' });\n  }\n\n  /**\n  * Parses the onMessage event on the connection and resolve the promise for the request.\n  * @param {Object} event - The event describing the message.\n  */\n  onMessage(event) {\n    const data = JSON.parse(event.data);\n    this.emit('traffic', 'received', data);\n    if (typeof data.id !== 'undefined') {\n      this.emit('message', data);\n      this.resolvers[data.id].resolveWith(data);\n    } else {\n      this.emit(data.params ? 'notification' : 'message', data);\n    }\n  }\n\n  /**\n  * Rejects all outstanding resolvers.\n  * @param {Object} reason - The reject reason.\n  */\n  rejectAllOutstandingResolvers(reason) {\n    Object.keys(this.resolvers).forEach((id) => {\n      if (id === 'opened' || id === 'closed') {\n        return; // \"opened\" and \"closed\" should not be handled here\n      }\n      const resolver = this.resolvers[id];\n      resolver.rejectWith(reason);\n    });\n  }\n\n  /**\n  * Unregisters a resolver.\n  * @param {Number|String} id - The ID to unregister the resolver with.\n  */\n  unregisterResolver(id) {\n    const resolver = this.resolvers[id];\n    resolver.removeAllListeners();\n    delete this.resolvers[id];\n  }\n\n  /**\n  * Registers a resolver.\n  * @param {Number|String} id - The ID to register the resolver with.\n  * @returns {Function} The promise executor function.\n  */\n  registerResolver(id, resolve, reject) {\n    const resolver = new RPCResolver(id, resolve, reject);\n    this.resolvers[id] = resolver;\n    resolver.on('resolved', resolvedId => this.unregisterResolver(resolvedId));\n    resolver.on('rejected', rejectedId => this.unregisterResolver(rejectedId));\n  }\n\n  /**\n  * Sends data on the socket.\n  * @param {Object} data - The data to send.\n  * @returns {Object} A promise instance.\n  */\n  send(data) {\n    if (!this.socket || this.socket.readyState !== this.socket.OPEN) {\n      return this.Promise.reject(new Error('Not connected'));\n    }\n    if (!data.id) {\n      data.id = this.createRequestId();\n    }\n    data.jsonrpc = '2.0';\n    return new this.Promise((resolve, reject) => {\n      this.socket.send(JSON.stringify(data));\n      this.emit('traffic', 'sent', data);\n      return this.registerResolver(data.id, resolve, reject);\n    });\n  }\n\n  createRequestId() {\n    this.requestId += 1;\n    return this.requestId;\n  }\n}\n\nexport default RPC;\n","const ON_ATTACHED_TIMEOUT_MS = 5000;\nconst RPC_CLOSE_MANUAL_SUSPEND = 4000;\n\nclass SuspendResume {\n  /**\n  * Creates a new SuspendResume instance.\n  * @param {Object} options The configuration option for this class.\n  * @param {Promise} options.Promise The promise constructor to use.\n  * @param {RPC} options.rpc The RPC instance to use when communicating towards Engine.\n  * @param {ApiCache} options.apis The ApiCache instance to use.\n  */\n  constructor(options) {\n    Object.assign(this, options);\n    this.isSuspended = false;\n    this.rpc.on('traffic', (dir, data) => {\n      if (dir === 'sent' && data.method === 'OpenDoc') {\n        this.openDocParams = data.params;\n      }\n    });\n  }\n\n  /**\n  * Function used to restore the rpc connection.\n  * @param {Boolean} onlyIfAttached - if true, the returned promise will resolve\n  *                                   only if the session can be re-attached.\n  * @returns {Object} Returns a promise instance.\n  */\n  restoreRpcConnection(onlyIfAttached) {\n    return this.reopen(ON_ATTACHED_TIMEOUT_MS).then((sessionState) => {\n      if (sessionState === 'SESSION_CREATED' && onlyIfAttached) {\n        return this.Promise.reject(new Error('Not attached'));\n      }\n      return this.Promise.resolve();\n    });\n  }\n\n  /**\n  * Function used to restore the global API.\n  * @param {Object} changed - A list where the restored APIs will be added.\n  * @returns {Object} Returns a promise instance.\n  */\n  restoreGlobal(changed) {\n    const global = this.apis.getApisByType('Global').pop();\n    changed.push(global.api);\n    return this.Promise.resolve();\n  }\n\n  /**\n  * Function used to restore the doc API.\n  * @param {String} sessionState - The state of the session, attached or created.\n  * @param {Array} closed - A list where the closed of APIs APIs will be added.\n  * @param {Object} changed - A list where the restored APIs will be added.\n  * @returns {Object} Returns a promise instance.\n  */\n  restoreDoc(closed, changed) {\n    const doc = this.apis.getApisByType('Doc').pop();\n\n    if (!doc) {\n      return this.Promise.resolve();\n    }\n\n    return this.rpc.send({\n      method: 'GetActiveDoc',\n      handle: -1,\n      params: [],\n    }).then((response) => {\n      if (response.error && this.openDocParams) {\n        return this.rpc.send({\n          method: 'OpenDoc',\n          handle: -1,\n          params: this.openDocParams,\n        });\n      }\n      return response;\n    }).then((response) => {\n      if (response.error) {\n        closed.push(doc.api);\n        return this.Promise.resolve();\n      }\n      const handle = response.result.qReturn.qHandle;\n      doc.api.handle = handle;\n      changed.push(doc.api);\n      return this.Promise.resolve(doc.api);\n    });\n  }\n\n  /**\n  * Function used to restore the APIs on the doc.\n  * @param {Object} doc - The doc API on which the APIs we want to restore exist.\n  * @param {Array} closed - A list where the closed of APIs APIs will be added.\n  * @param {Object} changed - A list where the restored APIs will be added.\n  * @returns {Object} Returns a promise instance.\n  */\n  restoreDocObjects(doc, closed, changed) {\n    const tasks = [];\n    const apis = this.apis.getApis()\n      .map(entry => entry.api)\n      .filter(api => api.type !== 'Global' && api.type !== 'Doc');\n\n    if (!doc) {\n      apis.forEach(api => closed.push(api));\n      return this.Promise.resolve();\n    }\n\n    apis.forEach((api) => {\n      const method = SuspendResume.buildGetMethodName(api.type);\n\n      if (!method) {\n        closed.push(api);\n      } else {\n        const request = this.rpc.send({\n          method,\n          handle: doc.handle,\n          params: [api.id],\n        }).then((response) => {\n          if (response.error || !response.result.qReturn.qHandle) {\n            closed.push(api);\n          } else {\n            api.handle = response.result.qReturn.qHandle;\n            changed.push(api);\n          }\n        });\n        tasks.push(request);\n      }\n    });\n    return this.Promise.all(tasks);\n  }\n\n  /**\n  * Set the instance as suspended.\n  */\n  suspend() {\n    this.isSuspended = true;\n    return this.rpc.close(RPC_CLOSE_MANUAL_SUSPEND);\n  }\n\n  /**\n  * Resumes a previously suspended RPC connection, and refreshes the API cache.\n  *                                APIs unabled to be restored has their 'closed'\n  *                                event triggered, otherwise 'changed'.\n  * @param {Boolean} onlyIfAttached if true, resume only if the session was re-attached.\n  * @returns {Promise} Eventually resolved if the RPC connection was successfully resumed,\n  *                    otherwise rejected.\n  */\n  resume(onlyIfAttached) {\n    const changed = [];\n    const closed = [];\n\n    return this.restoreRpcConnection(onlyIfAttached)\n      .then(() => this.restoreGlobal(changed))\n      .then(() => this.restoreDoc(closed, changed))\n      .then(doc => this.restoreDocObjects(doc, closed, changed))\n      .then(() => {\n        this.isSuspended = false;\n        this.apis.clear();\n        closed.forEach((api) => {\n          api.emit('closed');\n          api.removeAllListeners();\n        });\n        changed.forEach((api) => {\n          this.apis.add(api.handle, api);\n          if (api.type !== 'Global') {\n            api.emit('changed');\n          }\n        });\n      })\n      .catch(err => this.rpc.close().then(() => this.Promise.reject(err)));\n  }\n\n  /**\n  * Reopens the connection and waits for the OnConnected notification.\n  * @param {Number} timeout - The time to wait for the OnConnected notification.\n  * @returns {Object} A promise containing the session state (SESSION_CREATED or SESSION_ATTACHED).\n  */\n  reopen(timeout) {\n    let timer;\n    let notificationResolve;\n    let notificationReceived = false;\n    const notificationPromise = new this.Promise((resolve) => { notificationResolve = resolve; });\n\n    const waitForNotification = () => {\n      if (!notificationReceived) {\n        timer = setTimeout(() => notificationResolve('SESSION_CREATED'), timeout);\n      }\n      return notificationPromise;\n    };\n\n    const onNotification = (data) => {\n      if (data.method !== 'OnConnected') return;\n      clearTimeout(timer);\n      notificationResolve(data.params.qSessionState);\n      notificationReceived = true;\n    };\n\n    this.rpc.on('notification', onNotification);\n\n    return this.rpc.open(true)\n      .then(waitForNotification)\n      .then((state) => {\n        this.rpc.removeListener('notification', onNotification);\n        return state;\n      })\n      .catch((err) => {\n        this.rpc.removeListener('notification', onNotification);\n        return this.Promise.reject(err);\n      });\n  }\n\n  /**\n  * Function used to build the get method names for Doc APIs.\n  * @param {String} type - The API type.\n  * @returns {String} Returns the get method name, or undefined if the type cannot be restored.\n  */\n  static buildGetMethodName(type) {\n    if (type === 'Field' || type === 'Variable') {\n      return null;\n    }\n    if (type === 'GenericVariable') {\n      return 'GetVariableById';\n    }\n    return type.replace('Generic', 'Get');\n  }\n}\n\nexport default SuspendResume;\n","const SUCCESS_KEY = 'qSuccess';\n\nexport default function deltaRequestInterceptor(session, request) {\n  const delta = session.config.protocol.delta\n    && request.outKey !== -1\n    && request.outKey !== SUCCESS_KEY;\n  if (delta) {\n    request.delta = delta;\n  }\n  return request;\n}\n","/**\n* Response interceptor for generating APIs. Handles the quirks of engine not\n* returning an error when an object is missing.\n* @param {Object} session - The session the intercept is being executed on.\n* @param {Object} request - The JSON-RPC request.\n* @param {Object} response - The response.\n* @returns {Object} - Returns the generated API\n*/\nexport default function apiInterceptor(session, request, response) {\n  if (response.qHandle && response.qType) {\n    return session.getObjectApi({\n      handle: response.qHandle,\n      type: response.qType,\n      id: response.qGenericId,\n      genericType: response.qGenericType,\n    });\n  }\n  if (response.qHandle === null && response.qType === null) {\n    return session.config.Promise.reject(new Error('Object not found'));\n  }\n  return response;\n}\n","'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\nvar defineProperty = Object.defineProperty;\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) { /**/ }\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\n// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target\nvar setProperty = function setProperty(target, options) {\n\tif (defineProperty && options.name === '__proto__') {\n\t\tdefineProperty(target, options.name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\tvalue: options.newValue,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\ttarget[options.name] = options.newValue;\n\t}\n};\n\n// Return undefined instead of __proto__ if '__proto__' is not an own property\nvar getProperty = function getProperty(obj, name) {\n\tif (name === '__proto__') {\n\t\tif (!hasOwn.call(obj, name)) {\n\t\t\treturn void 0;\n\t\t} else if (gOPD) {\n\t\t\t// In early versions of node, obj['__proto__'] is buggy when obj has\n\t\t\t// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.\n\t\t\treturn gOPD(obj, name).value;\n\t\t}\n\t}\n\n\treturn obj[name];\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone;\n\tvar target = arguments[0];\n\tvar i = 1;\n\tvar length = arguments.length;\n\tvar deep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\tif (target == null || (typeof target !== 'object' && typeof target !== 'function')) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = getProperty(target, name);\n\t\t\t\tcopy = getProperty(options, name);\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: extend(deep, clone, copy) });\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: copy });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n","import originalExtend from 'extend';\n\nconst extend = originalExtend.bind(null, true);\nconst JSONPatch = {};\nconst { isArray } = Array;\nfunction isObject(v) { return v != null && !Array.isArray(v) && typeof v === 'object'; }\nfunction isUndef(v) { return typeof v === 'undefined'; }\nfunction isFunction(v) { return typeof v === 'function'; }\n\n/**\n* Generate an exact duplicate (with no references) of a specific value.\n*\n* @private\n* @param {Object} The value to duplicate\n* @returns {Object} a unique, duplicated value\n*/\nfunction generateValue(val) {\n  if (val) {\n    return extend({}, { val }).val;\n  }\n  return val;\n}\n\n/**\n* An additional type checker used to determine if the property is of internal\n* use or not a type that can be translated into JSON (like functions).\n*\n* @private\n* @param {Object} obj The object which has the property to check\n* @param {String} The property name to check\n* @returns {Boolean} Whether the property is deemed special or not\n*/\nfunction isSpecialProperty(obj, key) {\n  return isFunction(obj[key])\n    || key.substring(0, 2) === '$$'\n    || key.substring(0, 1) === '_';\n}\n\n/**\n* Finds the parent object from a JSON-Pointer (\"/foo/bar/baz\" = \"bar\" is \"baz\" parent),\n* also creates the object structure needed.\n*\n* @private\n* @param {Object} data The root object to traverse through\n* @param {String} The JSON-Pointer string to use when traversing\n* @returns {Object} The parent object\n*/\nfunction getParent(data, str) {\n  const seperator = '/';\n  const parts = str.substring(1).split(seperator).slice(0, -1);\n  let numPart;\n\n  parts.forEach((part, i) => {\n    if (i === parts.length) {\n      return;\n    }\n    numPart = +part;\n    const newPart = !isNaN(numPart) ? [] : {};\n    data[numPart || part] = isUndef(data[numPart || part])\n      ? newPart\n      : data[part];\n    data = data[numPart || part];\n  });\n\n  return data;\n}\n\n/**\n* Cleans an object of all its properties, unless they're deemed special or\n* cannot be removed by configuration.\n*\n* @private\n* @param {Object} obj The object to clean\n*/\nfunction emptyObject(obj) {\n  Object.keys(obj).forEach((key) => {\n    const config = Object.getOwnPropertyDescriptor(obj, key);\n\n    if (config.configurable && !isSpecialProperty(obj, key)) {\n      delete obj[key];\n    }\n  });\n}\n\n/**\n* Compare an object with another, could be object, array, number, string, bool.\n*\n* @param {Object} a The first object to compare\n* @param {Object} a The second object to compare\n* @returns {Boolean} Whether the objects are identical\n*/\nfunction compare(a, b) {\n  let isIdentical = true;\n\n  if (isObject(a) && isObject(b)) {\n    if (Object.keys(a).length !== Object.keys(b).length) {\n      return false;\n    }\n    Object.keys(a).forEach((key) => {\n      if (!compare(a[key], b[key])) {\n        isIdentical = false;\n      }\n    });\n    return isIdentical;\n  } if (isArray(a) && isArray(b)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (let i = 0, l = a.length; i < l; i += 1) {\n      if (!compare(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return a === b;\n}\n\n/**\n* Generates patches by comparing two arrays.\n*\n* @private\n* @param {Array} oldA The old (original) array, which will be patched\n* @param {Array} newA The new array, which will be used to compare against\n* @returns {Array} An array of patches (if any)\n*/\nfunction patchArray(original, newA, basePath) {\n  let patches = [];\n  const oldA = original.slice();\n  let tmpIdx = -1;\n\n  function findIndex(a, id, idx) {\n    if (a[idx] && isUndef(a[idx].qInfo)) {\n      return null;\n    } if (a[idx] && a[idx].qInfo.qId === id) {\n      // shortcut if identical\n      return idx;\n    }\n    for (let ii = 0, ll = a.length; ii < ll; ii += 1) {\n      if (a[ii] && a[ii].qInfo.qId === id) {\n        return ii;\n      }\n    }\n    return -1;\n  }\n\n  if (compare(newA, oldA)) {\n    // array is unchanged\n    return patches;\n  }\n\n  if (!isUndef(newA[0]) && isUndef(newA[0].qInfo)) {\n    // we cannot create patches without unique identifiers, replace array...\n    patches.push({\n      op: 'replace',\n      path: basePath,\n      value: newA,\n    });\n    return patches;\n  }\n\n  for (let i = oldA.length - 1; i >= 0; i -= 1) {\n    tmpIdx = findIndex(newA, oldA[i].qInfo && oldA[i].qInfo.qId, i);\n    if (tmpIdx === -1) {\n      patches.push({\n        op: 'remove',\n        path: `${basePath}/${i}`,\n      });\n      oldA.splice(i, 1);\n    } else {\n      patches = patches.concat(JSONPatch.generate(oldA[i], newA[tmpIdx], `${basePath}/${i}`));\n    }\n  }\n\n  for (let i = 0, l = newA.length; i < l; i += 1) {\n    tmpIdx = findIndex(oldA, newA[i].qInfo && newA[i].qInfo.qId);\n    if (tmpIdx === -1) {\n      patches.push({\n        op: 'add',\n        path: `${basePath}/${i}`,\n        value: newA[i],\n      });\n      oldA.splice(i, 0, newA[i]);\n    } else if (tmpIdx !== i) {\n      patches.push({\n        op: 'move',\n        path: `${basePath}/${i}`,\n        from: `${basePath}/${tmpIdx}`,\n      });\n      oldA.splice(i, 0, oldA.splice(tmpIdx, 1)[0]);\n    }\n  }\n  return patches;\n}\n\n/**\n* Generate an array of JSON-Patch:es following the JSON-Patch Specification Draft.\n*\n* See [specification draft](http://tools.ietf.org/html/draft-ietf-appsawg-json-patch-10)\n*\n* Does NOT currently generate patches for arrays (will replace them)\n*\n* @param {Object} original The object to patch to\n* @param {Object} newData The object to patch from\n* @param {String} [basePath] The base path to use when generating the paths for\n*                            the patches (normally not used)\n* @returns {Array} An array of patches\n*/\nJSONPatch.generate = function generate(original, newData, basePath) {\n  basePath = basePath || '';\n  let patches = [];\n\n  Object.keys(newData).forEach((key) => {\n    const val = generateValue(newData[key]);\n    const oldVal = original[key];\n    const tmpPath = `${basePath}/${key}`;\n\n    if (compare(val, oldVal) || isSpecialProperty(newData, key)) {\n      return;\n    }\n    if (isUndef(oldVal)) {\n      // property does not previously exist\n      patches.push({\n        op: 'add',\n        path: tmpPath,\n        value: val,\n      });\n    } else if (isObject(val) && isObject(oldVal)) {\n      // we need to generate sub-patches for this, since it already exist\n      patches = patches.concat(JSONPatch.generate(oldVal, val, tmpPath));\n    } else if (isArray(val) && isArray(oldVal)) {\n      patches = patches.concat(patchArray(oldVal, val, tmpPath));\n    } else {\n      // it's a simple property (bool, string, number)\n      patches.push({\n        op: 'replace',\n        path: `${basePath}/${key}`,\n        value: val,\n      });\n    }\n  });\n\n  Object.keys(original).forEach((key) => {\n    if (isUndef(newData[key]) && !isSpecialProperty(original, key)) {\n      // this property does not exist anymore\n      patches.push({\n        op: 'remove',\n        path: `${basePath}/${key}`,\n      });\n    }\n  });\n\n  return patches;\n};\n\n/**\n* Apply a list of patches to an object.\n*\n* @param {Object} original The object to patch\n* @param {Array} patches The list of patches to apply\n*/\nJSONPatch.apply = function apply(original, patches) {\n  patches.forEach((patch) => {\n    let parent = getParent(original, patch.path);\n    let key = patch.path.split('/').splice(-1)[0];\n    let target = key && isNaN(+key) ? parent[key] : parent[+key] || parent;\n    const from = patch.from ? patch.from.split('/').splice(-1)[0] : null;\n\n    if (patch.path === '/') {\n      parent = null;\n      target = original;\n    }\n\n    if (patch.op === 'add' || patch.op === 'replace') {\n      if (isArray(parent)) {\n        // trust indexes from patches, so don't replace the index if it's an add\n        if (key === '-') {\n          key = parent.length;\n        }\n        parent.splice(+key, patch.op === 'add' ? 0 : 1, patch.value);\n      } else if (isArray(target) && isArray(patch.value)) {\n        const newValues = patch.value.slice();\n        // keep array reference if possible...\n        target.length = 0;\n        target.push(...newValues);\n      } else if (isObject(target) && isObject(patch.value)) {\n        // keep object reference if possible...\n        emptyObject(target);\n        extend(target, patch.value);\n      } else if (!parent) {\n        throw new Error('Patchee is not an object we can patch');\n      } else {\n        // simple value\n        parent[key] = patch.value;\n      }\n    } else if (patch.op === 'move') {\n      const oldParent = getParent(original, patch.from);\n      if (isArray(parent)) {\n        parent.splice(+key, 0, oldParent.splice(+from, 1)[0]);\n      } else {\n        parent[key] = oldParent[from];\n        delete oldParent[from];\n      }\n    } else if (patch.op === 'remove') {\n      if (isArray(parent)) {\n        parent.splice(+key, 1);\n      } else {\n        delete parent[key];\n      }\n    }\n  });\n};\n\n/**\n* Deep clone an object.\n*\n* @param {Object} obj The object to clone\n* @returns {Object} A new object identical to the `obj`\n*/\nJSONPatch.clone = function clone(obj) {\n  return extend({}, obj);\n};\n\n/**\n* Creates a JSON-patch.\n*\n* @param {String} op The operation of the patch. Available values: \"add\", \"remove\", \"move\"\n* @param {Object} [val] The value to set the `path` to. If `op` is `move`, `val`\n*                       is the \"from JSON-path\" path\n* @param {String} path The JSON-path for the property to change (e.g. \"/qHyperCubeDef/columnOrder\")\n* @returns {Object} A patch following the JSON-patch specification\n*/\nJSONPatch.createPatch = function createPatch(op, val, path) {\n  const patch = {\n    op: op.toLowerCase(),\n    path,\n  };\n  if (patch.op === 'move') {\n    patch.from = val;\n  } else if (typeof val !== 'undefined') {\n    patch.value = val;\n  }\n  return patch;\n};\n\n/**\n* Apply the differences of two objects (keeping references if possible).\n* Identical to running `JSONPatch.apply(original, JSONPatch.generate(original, newData));`\n*\n* @param {Object} original The object to update/patch\n* @param {Object} newData the object to diff against\n*\n* @example\n* var obj1 = { foo: [1,2,3], bar: { baz: true, qux: 1 } };\n* var obj2 = { foo: [4,5,6], bar: { baz: false } };\n* JSONPatch.updateObject(obj1, obj2);\n* // => { foo: [4,5,6], bar: { baz: false } };\n*/\nJSONPatch.updateObject = function updateObject(original, newData) {\n  if (!Object.keys(original).length) {\n    extend(original, newData);\n    return;\n  }\n  JSONPatch.apply(original, JSONPatch.generate(original, newData));\n};\n\nexport default JSONPatch;\n","import JSONPatch from '../../json-patch';\nimport KeyValueCache from '../../cache';\n\nconst sessions = {};\n\n/**\n* Function to make sure we release handle caches when they are closed.\n*\n* @param {Session} session The session instance to listen on.\n*/\nconst bindSession = (session) => {\n  if (!sessions[session.id]) {\n    const cache = {};\n    sessions[session.id] = cache;\n    session.on('traffic:received', data => data.close && data.close.forEach(handle => delete cache[handle]));\n    session.on('closed', () => delete sessions[session.id]);\n  }\n};\n\n/**\n* Simple function that ensures the session events has been bound, and returns\n* either an existing key-value cache or creates one for the specified handle.\n*\n* @param {Session} session The session that owns the handle.\n* @param {Number} handle The object handle to retrieve the cache for.\n* @returns {KeyValueCache} The cache instance.\n*/\nconst getHandleCache = (session, handle) => {\n  bindSession(session);\n  const cache = sessions[session.id];\n  if (!cache[handle]) {\n    cache[handle] = new KeyValueCache();\n  }\n  return cache[handle];\n};\n\n/**\n* Function used to apply a list of patches and return the patched value.\n* @param {Session} session The session.\n* @param {Number} handle The object handle.\n* @param {String} cacheId The cacheId.\n* @param {Array} patches The patches.\n* @returns {Object} Returns the patched value.\n*/\nconst patchValue = (session, handle, cacheId, patches) => {\n  const cache = getHandleCache(session, handle);\n  let entry = cache.get(cacheId);\n  if (typeof entry === 'undefined') {\n    entry = Array.isArray(patches[0].value) ? [] : {};\n  }\n  if (patches.length) {\n    if (patches[0].path === '/' && typeof patches[0].value !== 'object') {\n      // 'plain' values on root path is not supported (no object reference),\n      // so we simply store the value directly:\n      entry = patches[0].value;\n    } else {\n      JSONPatch.apply(entry, patches);\n    }\n    cache.set(cacheId, entry);\n  }\n  return entry;\n};\n\n/**\n* Process delta interceptor.\n* @param {Session} session The session the intercept is being executed on.\n* @param {Object} request The JSON-RPC request.\n* @param {Object} response The response.\n* @returns {Object} Returns the patched response\n*/\nexport default function deltaInterceptor(session, request, response) {\n  const { delta, result } = response;\n  if (delta) {\n    // when delta is on the response data is expected to be an array of patches:\n    Object.keys(result).forEach((key) => {\n      if (!Array.isArray(result[key])) {\n        throw new Error('Unexpected RPC response, expected array of patches');\n      }\n      result[key] = patchValue(session, request.handle, `${request.method}-${key}`, result[key]);\n    });\n    // return a cloned response object to avoid patched object references:\n    return JSON.parse(JSON.stringify(response));\n  }\n  return response;\n}\n\n// export object reference for testing purposes:\ndeltaInterceptor.sessions = sessions;\n","const RETURN_KEY = 'qReturn';\n\n/**\n* Picks out the result \"out\" parameter based on the QIX method+schema, with\n* some specific handling for some methods that breaks the predictable protocol.\n* @param {Object} session - The session the intercept is being executed on.\n* @param {Object} request - The JSON-RPC request.\n* @param {Object} response - The response.\n* @returns {Object} - Returns the result property on the response\n*/\nexport default function outParamInterceptor(session, request, response) {\n  if (request.method === 'CreateSessionApp' || request.method === 'CreateSessionAppFromApp') {\n    // this method returns multiple out params that we need\n    // to normalize before processing the response further:\n    response[RETURN_KEY].qGenericId = response[RETURN_KEY].qGenericId || response.qSessionAppId;\n  } else if (request.method === 'GetInteract') {\n    // this method returns a qReturn value when it should only return\n    // meta.outKey:\n    delete response[RETURN_KEY];\n  }\n\n  if (hasOwnProperty.call(response, RETURN_KEY)) {\n    return response[RETURN_KEY];\n  }\n  if (request.outKey !== -1) {\n    return response[request.outKey];\n  }\n\n  return response;\n}\n","import deltaRequest from './interceptors/request/delta';\nimport apiResponse from './interceptors/response/api';\nimport deltaResponse from './interceptors/response/delta';\nimport errorResponse from './interceptors/response/error';\nimport outParamResponse from './interceptors/response/out-param';\nimport resultResponse from './interceptors/response/result';\n\nclass Intercept {\n  /**\n  * Create a new Intercept instance.\n  * @param {Object} options The configuration options for this class.\n  * @param {Promise} options.Promise The promise constructor to use.\n  * @param {ApiCache} options.apis The ApiCache instance to use.\n  * @param {Array<Object>} [options.request] The additional request interceptors to use.\n  * @param {Array<Object>} [options.response] The additional response interceptors to use.\n  */\n  constructor(options) {\n    Object.assign(this, options);\n    this.request = [{ onFulfilled: deltaRequest }, ...this.request || []];\n    this.response = [\n      { onFulfilled: errorResponse },\n      { onFulfilled: deltaResponse },\n      { onFulfilled: resultResponse },\n      { onFulfilled: outParamResponse },\n      ...this.response || [],\n      { onFulfilled: apiResponse },\n    ];\n  }\n\n  /**\n  * Execute the request interceptor queue, each interceptor will get the result from\n  * the previous interceptor.\n  * @param {Object} session The session instance to execute against.\n  * @param {Promise} promise The promise to chain on to.\n  * @returns {Promise}\n  */\n  executeRequests(session, promise) {\n    return this.request.reduce((interception, interceptor) => {\n      const intercept = interceptor.onFulfilled\n      && interceptor.onFulfilled.bind(this, session);\n      return interception.then(intercept);\n    }, promise);\n  }\n\n  /**\n  * Execute the response interceptor queue, each interceptor will get the result from\n  * the previous interceptor.\n  * @param {Object} session The session instance to execute against.\n  * @param {Promise} promise The promise to chain on to.\n  * @param {Object} request The JSONRPC request object for the intercepted response.\n  * @returns {Promise}\n  */\n  executeResponses(session, promise, request) {\n    return this.response.reduce((interception, interceptor) => interception.then(\n      interceptor.onFulfilled && interceptor.onFulfilled.bind(this, session, request),\n      interceptor.onRejected && interceptor.onRejected.bind(this, session, request),\n    ),\n    promise);\n  }\n}\n\nexport default Intercept;\n","/**\n* Process error interceptor.\n* @param {Object} session - The session the intercept is being executed on.\n* @param {Object} request - The JSON-RPC request.\n* @param {Object} response - The response.\n* @returns {Object} - Returns the defined error for an error, else the response.\n*/\nexport default function errorInterceptor(session, request, response) {\n  if (typeof response.error !== 'undefined') {\n    const data = response.error;\n    const error = new Error(data.message);\n    error.code = data.code;\n    error.parameter = data.parameter;\n    return session.config.Promise.reject(error);\n  }\n  return response;\n}\n","/**\n* Process result interceptor.\n* @param {Object} session - The session the intercept is being executed on.\n* @param {Object} request - The JSON-RPC request.\n* @param {Object} response - The response.\n* @returns {Object} - Returns the result property on the response\n*/\nexport default function resultInterceptor(session, request, response) {\n  return response.result;\n}\n","import KeyValueCache from './cache';\n\n/**\n* API cache for instances of QIX types, e.g. GenericObject.\n* @extends KeyValueCache\n*/\nclass ApiCache extends KeyValueCache {\n  /**\n  * Adds an API.\n  * @function ApiCache#add\n  * @param {Number} handle - The handle for the API.\n  * @param {*} api - The API.\n  * @returns {{api: *}} The entry.\n  */\n  add(handle, api) {\n    const entry = { api };\n    super.add(handle.toString(), entry);\n    api.on('closed', () => this.remove(handle));\n    return entry;\n  }\n\n  /**\n  * Gets an API.\n  * @function ApiCache#getApi\n  * @param {Number} handle - The handle for the API.\n  * @returns {*} The API for the handle.\n  */\n  getApi(handle) {\n    const entry = typeof handle !== 'undefined' ? this.get(handle.toString()) : undefined;\n    return entry && entry.api;\n  }\n\n  /**\n  * Gets a list of APIs.\n  * @function ApiCache#getApis\n  * @returns {Array} The list of entries including `handle` and `api` properties for each entry.\n  */\n  getApis() {\n    return super.getAll().map(entry => ({\n      handle: entry.key,\n      api: entry.value.api,\n    }));\n  }\n\n  /**\n  * Gets a list of APIs with a given type.\n  * @function ApiCache#getApisByType\n  * @param {String} type - The type of APIs to get.\n  * @returns {Array} The list of entries including `handle` and `api` properties for each entry.\n  */\n  getApisByType(type) {\n    return this.getApis().filter(entry => entry.api.type === type);\n  }\n}\n\nexport default ApiCache;\n","import Session from './session';\nimport Schema from './schema';\nimport RPC from './rpc';\nimport SuspendResume from './suspend-resume';\nimport Intercept from './intercept';\nimport ApiCache from './api-cache';\n\n/**\n* Qix service.\n*/\nclass Qix {\n  /**\n  * Function used to get a session.\n  * @param {Configuration} config The configuration object for this session.\n  * @returns {Object} Returns a session instance.\n  */\n  static getSession(config) {\n    const {\n      createSocket,\n      Promise,\n      requestInterceptors,\n      responseInterceptors,\n      url,\n    } = config;\n    const apis = new ApiCache();\n    const intercept = new Intercept({\n      apis,\n      Promise,\n      request: requestInterceptors,\n      response: responseInterceptors,\n    });\n    const rpc = new RPC({ createSocket, Promise, url });\n    const suspendResume = new SuspendResume({ apis, Promise, rpc });\n    const session = new Session({\n      apis,\n      config,\n      intercept,\n      rpc,\n      suspendResume,\n    });\n    return session;\n  }\n\n  /**\n  * Function used to create a QIX session.\n  * @param {Object} config The configuration object for the QIX session.\n  * @returns {Session} Returns a new QIX session.\n  */\n  static create(config) {\n    Qix.configureDefaults(config);\n    config.mixins.forEach((mixin) => {\n      config.definition.registerMixin(mixin);\n    });\n    return Qix.getSession(config);\n  }\n\n  /**\n  * Function used to configure defaults.\n  * @param {Configuration} config The configuration object for how to connect\n  *                               and retrieve end QIX APIs.\n  */\n  static configureDefaults(config) {\n    if (!config) {\n      throw new Error('You need to supply a configuration.');\n    }\n\n    // eslint-disable-next-line no-restricted-globals\n    if (!config.Promise && typeof Promise === 'undefined') {\n      throw new Error('Your environment has no Promise implementation. You must provide a Promise implementation in the config.');\n    }\n\n    if (typeof config.createSocket !== 'function' && typeof WebSocket === 'function') {\n      // eslint-disable-next-line no-undef\n      config.createSocket = url => new WebSocket(url);\n    }\n\n    if (typeof config.suspendOnClose === 'undefined') {\n      config.suspendOnClose = false;\n    }\n\n    config.protocol = config.protocol || {};\n    config.protocol.delta = typeof config.protocol.delta !== 'undefined' ? config.protocol.delta : true;\n    // eslint-disable-next-line no-restricted-globals\n    config.Promise = config.Promise || Promise;\n    config.mixins = config.mixins || [];\n    config.definition = config.definition || new Schema(config);\n  }\n}\n\nexport default Qix;\n"],"names":["util","EventEmitter","init","call","this","isObject","arg","isNumber","isUndefined","isFunction","prototype","_events","undefined","_maxListeners","defaultMaxListeners","setMaxListeners","n","isNaN","TypeError","emit","type","er","handler","len","args","i","listeners","error","arguments","Error","length","Array","apply","slice","on","addListener","listener","m","newListener","push","warned","console","trace","once","fired","g","removeListener","list","position","splice","removeAllListeners","key","isArray","listenerCount","emitter","obj","keys","forEach","cacheId","Session","options","session","Promise","config","definition","id","rpc","onRpcError","bind","onRpcClosed","onRpcMessage","onRpcNotification","onRpcTraffic","onSessionClosed","err","suspendResume","isSuspended","evt","code","suspendOnClose","suspend","then","_this","initiator","response","change","_this2","emitHandleChanged","handle","close","emitHandleClosed","method","params","dir","data","apis","getApis","entry","api","clear","genericType","getApi","generate","factory","add","globalPromise","open","_this3","getObjectApi","global","request","reject","createRequestId","promise","intercept","executeRequests","resolve","augmentedRequest","babelHelpers.extends","_this4","protocol","outKey","send","retry","executeResponses","addToPromiseChain","_this5","onlyIfAttached","resume","value","_this7","name","chain","KeyValueCache","entries","Object","map","filter","hasOwnProperty","toCamelCase","symbol","substring","toLowerCase","Schema","schema","mixins","types","extend","override","cached","typeKey","entryList","get","structs","generateApi","create","generateDefaultApi","mixinType","mixinNamedParamFacade","customKey","instance","defineProperties","mixinList","concat","mixin","out","Out","Name","fnName","baseFn","base","defaults","In","reduce","result","item","DefaultValue","babelHelpers.typeof","every","RPCResolver","RPC","resolvers","requestId","openedPromise","socket","createSocket","url","onopen","onOpen","onclose","onClose","onerror","onError","onmessage","onMessage","registerResolver","closedPromise","opened","resolveWith","event","closed","rejectAllOutstandingResolvers","message","reason","rejectWith","JSON","parse","resolver","unregisterResolver","resolvedId","rejectedId","readyState","OPEN","jsonrpc","stringify","SuspendResume","openDocParams","reopen","sessionState","changed","getApisByType","pop","doc","qReturn","qHandle","tasks","buildGetMethodName","all","restoreRpcConnection","restoreGlobal","restoreDoc","restoreDocObjects","catch","timeout","timer","notificationResolve","notificationReceived","notificationPromise","onNotification","qSessionState","setTimeout","state","_this6","replace","SUCCESS_KEY","apiInterceptor","qType","qGenericId","qGenericType","hasOwn","toStr","toString","defineProperty","gOPD","getOwnPropertyDescriptor","arr","isPlainObject","hasOwnConstructor","hasIsPrototypeOf","constructor","setProperty","target","enumerable","configurable","newValue","writable","getProperty","src","copy","copyIsArray","clone","deep","JSONPatch","v","isUndef","isSpecialProperty","getParent","str","parts","split","numPart","part","newPart","compare","a","b","isIdentical","l","original","newData","basePath","patches","val","oldVal","tmpPath","newA","oldA","tmpIdx","findIndex","idx","qInfo","qId","ii","ll","patchArray","patch","parent","path","from","op","newValues","oldParent","createPatch","updateObject","sessions","getHandleCache","cache","patchValue","set","deltaInterceptor","delta","RETURN_KEY","Intercept","onFulfilled","parameter","deltaResponse","qSessionAppId","apiResponse","interception","interceptor","onRejected","ApiCache","remove","babelHelpers.get","requestInterceptors","responseInterceptors","configureDefaults","registerMixin","Qix","getSession","WebSocket"],"mappings":"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"}